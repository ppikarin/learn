package com.ppikarin.back.core;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

@Service
@Slf4j
@RequiredArgsConstructor
public class ChallengeService {

    private final static int MINIMUM_FACTOR = 11;
    private final static int MAXIMUM_FACTOR = 100;

    private final HumanRepository humanRepository;
    private final AttemptRepository attemptRepository;

    public Attempt verifyAttempt(AttemptRDTO attemptDTO) {

        // Check if the human already exists for that alias, otherwise create it
        Human human = humanRepository
                .findByName(attemptDTO.getHumanName())
                .orElseGet(() -> {
                    log.info("Creating human user with alias {}", attemptDTO.getHumanName());
                    return humanRepository.save(new Human(attemptDTO.getHumanName()));
                });

        // Check if the attempt is correct
        boolean isCorrect = attemptDTO.getGuess() == attemptDTO.getFactorA() * attemptDTO.getFactorB();

        // Builds the domain object. Null id since it'll be generated by the DB.
        Attempt checkedAttempt = new Attempt(
                null,
                human,
                attemptDTO.getFactorA(),
                attemptDTO.getFactorB(),
                attemptDTO.getGuess(),
                isCorrect);

        // Stores the attempt
        Attempt storedAttempt = attemptRepository.save(checkedAttempt);
        return storedAttempt;
    }

    public List<AttemptDTO> getStatsForHuman(String humanName) {
        return attemptRepository
                .findTop10ByHumanNameOrderByIdDesc(humanName)
                .stream()
                .map(this::toDto)
                .collect(Collectors.toList());
    }

    public List<AttemptDTO> getAllStats() {
        return StreamSupport
                .stream(attemptRepository.findAll().spliterator(), false)
                .map(this::toDto)
                .collect(Collectors.toList());
    }

    private AttemptDTO toDto(Attempt attempt) {

        AttemptDTO dto = new AttemptDTO();

        dto.setCorrect(attempt.isCorrect());
        dto.setFactorA(attempt.getFactorA());
        dto.setFactorB(attempt.getFactorB());
        dto.setHuman(attempt.getHuman().getName());
        dto.setResultAttempt(attempt.getResultAttempt());

        return dto;
    }

}